Switch to a branch packaged in Fedora, also seen in upstream commit
72ac94b2637b73f23ef98b2f6fe9c622ad4287fc.  Update the API to get/set a register
by switching to variable byte slices instead of integers.

--- a/src/vmm/Cargo.toml
+++ b/src/vmm/Cargo.toml
@@ -10,7 +10,7 @@
 derive_more = { version = "0.99.17", default-features = false, features = ["from", "display"] }
 event-manager = "0.3.0"
 kvm-bindings = { version = "0.6.0", features = ["fam-wrappers"] }
-kvm-ioctls = "0.12.0"
+kvm-ioctls = "0.14.0"
 lazy_static = "1.4.0"
 libc = "0.2.117"
 linux-loader = "0.8.1"
--- a/src/vmm/src/arch/aarch64/regs.rs
+++ b/src/vmm/src/arch/aarch64/regs.rs
@@ -229,7 +229,7 @@
     let pstate = offset__of!(user_pt_regs, pstate) + kreg_off;
     vcpu.set_one_reg(
         arm64_core_reg_id!(KVM_REG_SIZE_U64, pstate),
-        PSTATE_FAULT_BITS_64.into(),
+        &PSTATE_FAULT_BITS_64.to_le_bytes(),
     )
     .map_err(|err| Error::SetCoreRegister(err, "processor state".to_string()))?;
 
@@ -237,7 +237,7 @@
     if cpu_id == 0 {
         // Setting the PC (Processor Counter) to the current program address (kernel address).
         let pc = offset__of!(user_pt_regs, pc) + kreg_off;
-        vcpu.set_one_reg(arm64_core_reg_id!(KVM_REG_SIZE_U64, pc), boot_ip.into())
+        vcpu.set_one_reg(arm64_core_reg_id!(KVM_REG_SIZE_U64, pc), &boot_ip.to_le_bytes())
             .map_err(|err| Error::SetCoreRegister(err, "program counter".to_string()))?;
 
         // Last mandatory thing to set -> the address pointing to the FDT (also called DTB).
@@ -247,7 +247,7 @@
         let regs0 = offset__of!(user_pt_regs, regs) + kreg_off;
         vcpu.set_one_reg(
             arm64_core_reg_id!(KVM_REG_SIZE_U64, regs0),
-            get_fdt_addr(mem).into(),
+            &get_fdt_addr(mem).to_le_bytes(),
         )
         .map_err(|err| Error::SetCoreRegister(err, "X0".to_string()))?;
     }
@@ -279,11 +279,12 @@
 ///
 /// * `vcpu` - Structure for the VCPU that holds the VCPU's fd.
 pub fn read_mpidr(vcpu: &VcpuFd) -> Result<u64> {
-    match vcpu.get_one_reg(MPIDR_EL1) {
+    let mut mpidr = [0_u8; 8];
+    match vcpu.get_one_reg(MPIDR_EL1, &mut mpidr) {
         Err(err) => Err(Error::GetSysRegister(MPIDR_EL1, err)),
         // MPIDR register is 64 bit wide on aarch64, this expect cannot fail
         // on supported architectures
-        Ok(val) => Ok(val.try_into().expect("MPIDR register to be 64 bit")),
+        Ok(_) => Ok(u64::from_le_bytes(mpidr)),
     }
 }
 
@@ -304,9 +305,9 @@
         let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
         state.push(Aarch64Register {
             id,
-            value: vcpu
-                .get_one_reg(id)
-                .map_err(|err| Error::GetCoreRegister(err, format!("X{}", i)))?,
+            value: { let mut val = [0_u8; 8]; vcpu
+                .get_one_reg(id, &mut val)
+                .map_err(|err| Error::GetCoreRegister(err, format!("X{}", i)))?; u64::from_le_bytes(val).into() },
         });
         off += std::mem::size_of::<u64>();
     }
@@ -317,9 +318,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "stack pointer".to_string()))?,
+        value: { let mut val = [0_u8; 8]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "stack pointer".to_string()))?; u64::from_le_bytes(val).into() },
     });
 
     // Second one, the program counter.
@@ -327,9 +328,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "program counter".to_string()))?,
+        value: { let mut val = [0_u8; 8]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "program counter".to_string()))?; u64::from_le_bytes(val).into() },
     });
 
     // Next is the processor state.
@@ -337,9 +338,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "processor state".to_string()))?,
+        value: { let mut val = [0_u8; 8]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "processor state".to_string()))?; u64::from_le_bytes(val).into() },
     });
 
     // The stack pointer associated with EL1.
@@ -347,9 +348,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "SP_EL1".to_string()))?,
+        value: { let mut val = [0_u8; 8]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "SP_EL1".to_string()))?; u64::from_le_bytes(val).into() },
     });
 
     // Exception Link Register for EL1, when taking an exception to EL1, this register
@@ -358,9 +359,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "ELR_EL1".to_string()))?,
+        value: { let mut val = [0_u8; 8]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "ELR_EL1".to_string()))?; u64::from_le_bytes(val).into() },
     });
 
     // Saved Program Status Registers, there are 5 of them used in the kernel.
@@ -369,9 +370,9 @@
         let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
         state.push(Aarch64Register {
             id,
-            value: vcpu
-                .get_one_reg(id)
-                .map_err(|err| Error::GetCoreRegister(err, format!("SPSR{}", i)))?,
+            value: { let mut val = [0_u8; 8]; vcpu
+                .get_one_reg(id, &mut val)
+                .map_err(|err| Error::GetCoreRegister(err, format!("SPSR{}", i)))?; u64::from_le_bytes(val).into() },
         });
         off += std::mem::size_of::<u64>();
     }
@@ -383,9 +384,9 @@
         let id = arm64_core_reg_id!(KVM_REG_SIZE_U128, off);
         state.push(Aarch64Register {
             id,
-            value: vcpu
-                .get_one_reg(id)
-                .map_err(|err| Error::GetCoreRegister(err, format!("FP_VREG{}", i)))?,
+            value: { let mut val = [0_u8; 16]; vcpu
+                .get_one_reg(id, &mut val)
+                .map_err(|err| Error::GetCoreRegister(err, format!("FP_VREG{}", i)))?; u128::from_le_bytes(val) },
         });
         off += mem::size_of::<u128>();
     }
@@ -395,9 +396,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U32, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "FPSR".to_string()))?,
+        value: { let mut val = [0_u8; 4]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "FPSR".to_string()))?; u32::from_le_bytes(val).into() },
     });
 
     // Floating-point Control Register.
@@ -405,9 +406,9 @@
     let id = arm64_core_reg_id!(KVM_REG_SIZE_U32, off);
     state.push(Aarch64Register {
         id,
-        value: vcpu
-            .get_one_reg(id)
-            .map_err(|err| Error::GetCoreRegister(err, "FPCR".to_string()))?,
+        value: { let mut val = [0_u8; 4]; vcpu
+            .get_one_reg(id, &mut val)
+            .map_err(|err| Error::GetCoreRegister(err, "FPCR".to_string()))?; u32::from_le_bytes(val).into() },
     });
 
     Ok(())
@@ -451,9 +452,9 @@
     for id in ids.iter() {
         state.push(Aarch64Register {
             id: *id,
-            value: vcpu
-                .get_one_reg(*id)
-                .map_err(|e| Error::GetSysRegister(*id, e))?,
+            value: { let mut val = [0_u8; 16]; vcpu
+                .get_one_reg(*id, &mut val)
+                .map_err(|e| Error::GetSysRegister(*id, e))?; u128::from_le_bytes(val) },
         });
     }
 
@@ -468,7 +469,7 @@
 /// * `state` - Structure containing the state of the system registers.
 pub fn restore_registers(vcpu: &VcpuFd, state: &[Aarch64Register]) -> Result<()> {
     for reg in state {
-        vcpu.set_one_reg(reg.id, reg.value)
+        vcpu.set_one_reg(reg.id, &reg.value.to_le_bytes())
             .map_err(|e| Error::SetSysRegister(reg.id, e))?;
     }
     Ok(())
@@ -586,10 +587,11 @@
         restore_registers(&vcpu, &state).unwrap();
         let off = offset__of!(user_pt_regs, pstate);
         let id = arm64_core_reg_id!(KVM_REG_SIZE_U64, off);
+        let mut val = [0_u8; 8];
         let pstate = vcpu
-            .get_one_reg(id)
+            .get_one_reg(id, &mut val)
             .expect("Failed to call kvm get one reg");
-        assert!(state.contains(&Aarch64Register { id, value: pstate }));
+        assert!(state.contains(&Aarch64Register { id, value: u64::from_le_bytes(val).into() }));
     }
 
     #[test]
--- a/src/vmm/src/vstate/vcpu/aarch64.rs
+++ b/src/vmm/src/vstate/vcpu/aarch64.rs
@@ -102,7 +102,7 @@
     ) -> std::result::Result<(), Error> {
         for Aarch64Register { id, value } in vcpu_config.cpu_config.regs.iter() {
             self.fd
-                .set_one_reg(*id, *value)
+                .set_one_reg(*id, &value.to_le_bytes())
                 .map_err(|err| Error::ApplyCpuTemplate(ArchError::SetOneReg(*id, err)))?;
         }
         self.additional_register_ids = vcpu_config.cpu_config.register_ids();
@@ -230,9 +230,10 @@
         reg_list
             .iter()
             .map(|id| {
-                self.fd
-                    .get_one_reg(*id)
-                    .map(|value| Aarch64Register { id: *id, value })
+                let mut val = [0_u8; 16];
+                let result = self.fd.get_one_reg(*id, &mut val);
+                result
+                    .map(|_| Aarch64Register { id: *id, value: u128::from_le_bytes(val) })
                     .map_err(|err| ArchError::GetOneReg(*id, err))
             })
             .collect::<std::result::Result<Vec<_>, ArchError>>()
@@ -388,13 +389,14 @@
         assert!(!state.regs.is_empty());
         vcpu.restore_state(&state)
             .expect("Cannot restore state of vcpu");
+        let mut val = [0_u8; 16];
         let value = vcpu
             .fd
-            .get_one_reg(0x6030_0000_0010_003E)
+            .get_one_reg(0x6030_0000_0010_003E, &mut val)
             .expect("Cannot get sp core register");
         assert!(state.regs.contains(&Aarch64Register {
             id: 0x6030_0000_0010_003E,
-            value
+            u128::from_le_bytes(val)
         }));
     }
 
